SOURCE CODE:



// C/C++ program to solve fractional Knapsack Problem #include <bits/stdc++.h> using namespace std;
// Structure for an item which stores weight and



// corresponding value of Item struct Item {
 
int value, weight;

// Constructor

Item(int value, int weight) {

this->value=value; this->weight=weight;

}



};

bool cmp(struct Item a, struct Item b) {



double r1 = (double)a.value / (double)a.weight; double r2 = (double)b.value / (double)b.weight; return r1 > r2;



}

// Main greedy function to solve problem

double fractionalKnapsack(int W, struct Item arr[], int n) {













Fractional knapsack problem is solved using greedy method in the following steps- Step-01 : For each item, compute its value / weight ratio.
Step-02 : Arrange all the items in decreasing order of their value / weight ratio.

Step-03 : Start putting the items into the knapsack beginning from the item with the highest ratio.



Put as many items as you can into the knapsack.
 










// sorting Item on basis of ratio















sort(arr, arr + n, cmp);

int curWeight = 0; // Current weight in knapsack double finalvalue = 0.0; // Result (value in Knapsack) // Looping through all Items

for (int i = 0; i < n; i++)



// If adding Item won't overflow, add it completely if (curWeight + arr[i].weight <= W) {



curWeight += arr[i].weight; finalvalue += arr[i].value;



} else {



} }



// Returning final value return finalvalue;
 
}

// Driver code int main()

{











{











}











int remain = W - curWeight; finalvalue += arr[i].value



* ((double)remain



/ (double)arr[i].weight); break;
 






int W = 50; // Weight of knapsack

Item arr[] = { { 60, 10 }, { 100, 20 }, { 120, 30 } }; int n = sizeof(arr) / sizeof(arr[0]);

// Function call

cout << "Maximum value we can obtain = "



<< fractionalKnapsack(W, arr, n); return 0;
